name: Splatoon3 Result Uploader

on:
  schedule:
    - cron: '0 0-23/2 * * *'  # 2時間ごとにこのワークフローを実行
  workflow_dispatch:  # 手動でワークフローをトリガーするオプション

jobs:
  build:
    runs-on: ubuntu-latest  # Ubuntuの最新環境でジョブを実行
    env:
      CONFIG_TXT: ${{ secrets.CONFIG_TXT }}  # GitHub Secretsから取得した設定内容
      MY_GITHUB_PAT: ${{ secrets.MY_GITHUB_PAT }} # シークレット更新用のPersonal Access Token (PAT)

    name: Upload BattleLogs  # ジョブの名前
    steps:
      - name: Checkout repository
        uses: actions/checkout@v3

      # Node.js のセットアップ
      - name: Set up Node.js
        uses: actions/setup-node@v3
        with:
          node-version: '16'  # 使用するNode.jsのバージョン

      # frozenpandaman/s3sのリポジトリをチェックアウト
      - name: Checkout frozenpandaman/s3s
        uses: actions/checkout@v3
        with:
          repository: 'frozenpandaman/s3s'  # チェックアウトするリポジトリの指定
          path: s3s  # リポジトリをチェックアウトするパス

      # Python 3.11のセットアップ
      - name: Set up Python 3.11
        uses: actions/setup-python@v4
        with:
          python-version: 3.11  # 使用するPythonのバージョン
          cache: 'pip'  # pipのキャッシュを有効にする
          cache-dependency-path: 's3s/requirements.txt'  # 依存関係のキャッシュ用のパス

      # シークレットから読み込んだCONFIG_TXTをconfig.txtとして保存
      - name: Generate config.txt
        working-directory: s3s
        run: |
          echo '${{ env.CONFIG_TXT }}' > config.txt  # シークレットをconfig.txtに書き込む

      # s3sの依存パッケージをインストール
      - name: Install s3s requirements
        working-directory: s3s
        run: |
          pip install -r requirements.txt

      # s3sを実行し、バトルログをアップロード (必要に応じてトークンを再生成)
      - name: Run s3s
        working-directory: s3s
        run: |
          python3 s3s.py -r

      # config.txtが更新された場合のみ、GitHub Secretsを更新
      - name: Update GitHub Secrets with new config.txt (if updated)
        if: ${{ steps.check_update.outputs.updated == 'true' }}
        run: |
          echo "Updating GitHub Secrets..."

          # 必要なモジュールをインポート
          npm install axios tweetsodium @actions/core

          const axios = require('axios');
          const sodium = require('tweetsodium');
          const fs = require('fs');
          const core = require('@actions/core');

          // GitHub パーソナルアクセストークン
          const GITHUB_PAT = process.env.MY_GITHUB_PAT;

          // シークレットを設定するリポジトリ情報
          const REPO_OWNER = "gorinngo07";
          const REPO_NAME = "Splatoon3_Result_Uploader";

          // シークレットの名前とその値
          const SECRET_NAME = "CONFIG_TXT";
          const SECRET_FILE_PATH = 's3s/config.txt';  // ファイルパスを指定

          async function getPublicKey() {
            try {
              const response = await axios.get(`https://api.github.com/repos/${REPO_OWNER}/${REPO_NAME}/actions/secrets/public-key`, {
                headers: {
                  Authorization: `Bearer ${GITHUB_PAT}`,
                  Accept: 'application/vnd.github.v3+json'
                }
              });
              return { key: response.data.key, key_id: response.data.key_id };
            } catch (error) {
              core.error("公開鍵の取得に失敗しました: " + error.message);
              if (error.response) {
                core.error(`レスポンスデータ: ${JSON.stringify(error.response.data)}`);
                core.error(`レスポンスステータス: ${error.response.status}`);
              }
              process.exit(1);
            }
          }

          function encryptSecret(publicKey, secretValue) {
            const key = Buffer.from(publicKey, 'base64');
            const value = Buffer.from(secretValue);
            const encryptedBytes = sodium.seal(value, key);
            return Buffer.from(encryptedBytes).toString('base64');
          }

          async function createOrUpdateSecret(keyId, encryptedValue) {
            try {
              const response = await axios.put(
                `https://api.github.com/repos/${REPO_OWNER}/${REPO_NAME}/actions/secrets/${SECRET_NAME}`,
                { encrypted_value: encryptedValue, key_id: keyId },
                {
                  headers: {
                    Authorization: `Bearer ${GITHUB_PAT}`,
                    Accept: 'application/vnd.github.v3+json'
                  }
                }
              );
              core.info(`${SECRET_NAME} が正常に作成または更新されました`);
              core.info(`Response status: ${response.status}`);
            } catch (error) {
              core.error("シークレットの作成または更新に失敗しました: " + error.message);
              if (error.response) {
                core.error(`レスポンスデータ: ${JSON.stringify(error.response.data)}`);
                core.error(`レスポンスステータス: ${error.response.status}`);
              }
              process.exit(1);
            }
          }

          (async () => {
            try {
              const { key, key_id } = await getPublicKey();
              const secretValue = fs.readFileSync(SECRET_FILE_PATH, 'utf-8');
              core.info("シークレットの内容を読み込みました");
              const encryptedValue = encryptSecret(key, secretValue);
              await createOrUpdateSecret(key_id, encryptedValue);
            } catch (error) {
              core.setFailed(`エラーが発生しました: ${error.message}`);
              if (error.response) {
                core.error(`レスポンスデータ: ${JSON.stringify(error.response.data)}`);
                core.error(`レスポンスステータス: ${error.response.status}`);
              }
            }
          })();
